/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import { XHR } from "./XHR"
import { BearerToken } from "../model/BearerToken"
import { CertificateInfo } from "../model/CertificateInfo"
import { SamlTokenResult } from "../model/SamlTokenResult"
import { TokenResponse } from "../model/TokenResponse"
import { UUIDType } from "../model/UUIDType"

export class fhcStsApi {
  host: string
  headers: Array<XHR.Header>
  fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>

  constructor(
    host: string,
    headers: any,
    fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>
  ) {
    this.host = host
    this.headers = Object.keys(headers).map(k => new XHR.Header(k, headers[k]))
    this.fetchImpl = fetchImpl
  }

  setHeaders(h: Array<XHR.Header>) {
    this.headers = h
  }

  handleError(e: XHR.XHRError): never {
    throw e
  }

  /**
   *
   * @summary checkKeystoreExist
   * @param xFHCKeystoreId X-FHC-keystoreId
   */
  checkKeystoreExistUsingGET(xFHCKeystoreId: string): Promise<boolean> {
    let _body = null

    const _url = this.host + `/sts/keystore/check` + "?ts=" + new Date().getTime()
    let headers = this.headers
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => JSON.parse(JSON.stringify(doc.body)))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary checkTokenValid
   * @param xFHCTokenId X-FHC-tokenId
   */
  checkTokenValidUsingGET(xFHCTokenId: string): Promise<boolean> {
    let _body = null

    const _url = this.host + `/sts/token/check` + "?ts=" + new Date().getTime()
    let headers = this.headers
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => JSON.parse(JSON.stringify(doc.body)))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getBearerToken
   * @param xFHCTokenId X-FHC-tokenId
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param ssin ssin
   * @param xFHCKeystoreId X-FHC-keystoreId
   */
  getBearerTokenUsingGET(
    xFHCTokenId: string,
    xFHCPassPhrase: string,
    ssin: string,
    xFHCKeystoreId: string
  ): Promise<BearerToken> {
    let _body = null

    const _url =
      this.host +
      `/sts/token/bearer` +
      "?ts=" +
      new Date().getTime() +
      (ssin ? "&ssin=" + encodeURIComponent(String(ssin)) : "")
    let headers = this.headers
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new BearerToken(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getKeystoreInfo
   * @param keystoreId keystoreId
   * @param xFHCPassPhrase X-FHC-passPhrase
   */
  getKeystoreInfoUsingGET(keystoreId: string, xFHCPassPhrase: string): Promise<CertificateInfo> {
    let _body = null

    const _url =
      this.host +
      `/sts/keystore/${encodeURIComponent(String(keystoreId))}/info` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new CertificateInfo(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary getOauth2Token
   * @param xFHCTokenId X-FHC-tokenId
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param cbe cbe
   * @param kid kid
   */
  getOauth2TokenUsingGET(
    xFHCTokenId: string,
    xFHCPassPhrase: string,
    xFHCKeystoreId: string,
    cbe: string,
    kid: string
  ): Promise<TokenResponse> {
    let _body = null

    const _url =
      this.host +
      `/sts/token/oauth2/${encodeURIComponent(String(cbe))}/${encodeURIComponent(String(kid))}` +
      "?ts=" +
      new Date().getTime()
    let headers = this.headers
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new TokenResponse(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary registerToken
   * @param body token
   * @param xFHCTokenId X-FHC-tokenId
   * @param quality quality
   */
  registerTokenUsingPOST(
    xFHCTokenId: string,
    quality?: string,
    body?: string
  ): Promise<any | Boolean> {
    let _body = null
    _body = body

    const _url =
      this.host +
      `/sts/token` +
      "?ts=" +
      new Date().getTime() +
      (quality ? "&quality=" + encodeURIComponent(String(quality)) : "")
    let headers = this.headers
    headers = headers
      .filter(h => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "application/json"))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then(doc => true)
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary requestToken
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param ssin ssin
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param quality quality
   * @param xFHCTokenId X-FHC-tokenId
   */
  requestTokenUsingGET(
    xFHCPassPhrase: string,
    ssin: string,
    xFHCKeystoreId: string,
    quality: string,
    xFHCTokenId?: string
  ): Promise<SamlTokenResult> {
    let _body = null

    const _url =
      this.host +
      `/sts/token/${encodeURIComponent(String(quality))}` +
      "?ts=" +
      new Date().getTime() +
      (ssin ? "&ssin=" + encodeURIComponent(String(ssin)) : "")
    let headers = this.headers
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new SamlTokenResult(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary requestToken
   * @param xFHCPassPhrase X-FHC-passPhrase
   * @param ssin ssin
   * @param xFHCKeystoreId X-FHC-keystoreId
   * @param isMedicalHouse isMedicalHouse
   * @param isGuardPost isGuardPost
   * @param isSortingCenter isSortingCenter
   * @param xFHCTokenId X-FHC-tokenId
   */
  requestTokenUsingGET1(
    xFHCPassPhrase: string,
    ssin: string,
    xFHCKeystoreId: string,
    isMedicalHouse?: boolean,
    isGuardPost?: boolean,
    isSortingCenter?: boolean,
    xFHCTokenId?: string
  ): Promise<SamlTokenResult> {
    let _body = null

    const _url =
      this.host +
      `/sts/token` +
      "?ts=" +
      new Date().getTime() +
      (ssin ? "&ssin=" + encodeURIComponent(String(ssin)) : "") +
      (isMedicalHouse ? "&isMedicalHouse=" + encodeURIComponent(String(isMedicalHouse)) : "") +
      (isGuardPost ? "&isGuardPost=" + encodeURIComponent(String(isGuardPost)) : "") +
      (isSortingCenter ? "&isSortingCenter=" + encodeURIComponent(String(isSortingCenter)) : "")
    let headers = this.headers
    xFHCPassPhrase && (headers = headers.concat(new XHR.Header("X-FHC-passPhrase", xFHCPassPhrase)))
    xFHCKeystoreId && (headers = headers.concat(new XHR.Header("X-FHC-keystoreId", xFHCKeystoreId)))
    xFHCTokenId && (headers = headers.concat(new XHR.Header("X-FHC-tokenId", xFHCTokenId)))
    return XHR.sendCommand("GET", _url, headers, _body, this.fetchImpl)
      .then(doc => new SamlTokenResult(doc.body as JSON))
      .catch(err => this.handleError(err))
  }

  /**
   *
   * @summary uploadKeystore
   * @param file
   */
  uploadKeystoreUsingPOST(file: ArrayBuffer | any[]): Promise<UUIDType> {
    let _body = null
    if (file && !_body) {
      const parts = Array.isArray(file) ? (file as any[]) : [file as ArrayBuffer]
      const _blob = new Blob(parts, { type: "application/octet-stream" })
      _body = new FormData()
      _body.append("file", _blob)
    }

    const _url = this.host + `/sts/keystore` + "?ts=" + new Date().getTime()
    let headers = this.headers
    headers = headers
      .filter(h => h.header !== "Content-Type")
      .concat(new XHR.Header("Content-Type", "multipart/form-data"))
    return XHR.sendCommand("POST", _url, headers, _body, this.fetchImpl)
      .then(doc => new UUIDType(doc.body as JSON))
      .catch(err => this.handleError(err))
  }
}
